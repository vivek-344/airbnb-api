// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: room_availability.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRoomAvailability = `-- name: CreateRoomAvailability :one
INSERT INTO room_availability (
  room_id,
  date,
  is_available,
  night_rate
) VALUES (
  $1, $2, $3, $4
)
RETURNING room_id, date, is_available, night_rate
`

type CreateRoomAvailabilityParams struct {
	RoomID      pgtype.Int4    `json:"room_id"`
	Date        pgtype.Date    `json:"date"`
	IsAvailable pgtype.Bool    `json:"is_available"`
	NightRate   pgtype.Numeric `json:"night_rate"`
}

func (q *Queries) CreateRoomAvailability(ctx context.Context, arg CreateRoomAvailabilityParams) (RoomAvailability, error) {
	row := q.db.QueryRow(ctx, createRoomAvailability,
		arg.RoomID,
		arg.Date,
		arg.IsAvailable,
		arg.NightRate,
	)
	var i RoomAvailability
	err := row.Scan(
		&i.RoomID,
		&i.Date,
		&i.IsAvailable,
		&i.NightRate,
	)
	return i, err
}

const deleteRoomAvailabilityData = `-- name: DeleteRoomAvailabilityData :exec
DELETE FROM room_availability WHERE date < CURRENT_DATE
`

func (q *Queries) DeleteRoomAvailabilityData(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteRoomAvailabilityData)
	return err
}

const getAvailabilityPercentage = `-- name: GetAvailabilityPercentage :many
SELECT
  EXTRACT(YEAR FROM date) AS year,
  EXTRACT(MONTH FROM date) AS month,
  COUNT(CASE WHEN is_available THEN 1 END) * 100.0 / COUNT(*) AS availability_percentage
FROM room_availability
WHERE room_id = $1
GROUP BY year, month
ORDER BY year, month
`

type GetAvailabilityPercentageRow struct {
	Year                   pgtype.Numeric `json:"year"`
	Month                  pgtype.Numeric `json:"month"`
	AvailabilityPercentage int32          `json:"availability_percentage"`
}

func (q *Queries) GetAvailabilityPercentage(ctx context.Context, roomID pgtype.Int4) ([]GetAvailabilityPercentageRow, error) {
	rows, err := q.db.Query(ctx, getAvailabilityPercentage, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailabilityPercentageRow{}
	for rows.Next() {
		var i GetAvailabilityPercentageRow
		if err := rows.Scan(&i.Year, &i.Month, &i.AvailabilityPercentage); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAverageRate = `-- name: GetAverageRate :one
SELECT AVG(night_rate) 
FROM room_availability
WHERE room_id = $1
  AND date >= CURRENT_DATE 
  AND date < CURRENT_DATE + INTERVAL '30 days'
`

func (q *Queries) GetAverageRate(ctx context.Context, roomID pgtype.Int4) (float64, error) {
	row := q.db.QueryRow(ctx, getAverageRate, roomID)
	var avg float64
	err := row.Scan(&avg)
	return avg, err
}

const getDateCount = `-- name: GetDateCount :one
SELECT COUNT(DISTINCT date) FROM room_availability
`

func (q *Queries) GetDateCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getDateCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getMaximumRate = `-- name: GetMaximumRate :one
SELECT MAX(night_rate) 
FROM room_availability
WHERE room_id = $1
  AND date >= CURRENT_DATE 
  AND date < CURRENT_DATE + INTERVAL '30 days'
`

func (q *Queries) GetMaximumRate(ctx context.Context, roomID pgtype.Int4) (interface{}, error) {
	row := q.db.QueryRow(ctx, getMaximumRate, roomID)
	var max interface{}
	err := row.Scan(&max)
	return max, err
}

const getMinimumRate = `-- name: GetMinimumRate :one
SELECT MIN(night_rate) 
FROM room_availability
WHERE room_id = $1
  AND date >= CURRENT_DATE 
  AND date < CURRENT_DATE + INTERVAL '30 days'
`

func (q *Queries) GetMinimumRate(ctx context.Context, roomID pgtype.Int4) (interface{}, error) {
	row := q.db.QueryRow(ctx, getMinimumRate, roomID)
	var min interface{}
	err := row.Scan(&min)
	return min, err
}

const getRoomAvailabilityByDate = `-- name: GetRoomAvailabilityByDate :one
SELECT room_id, date, is_available, night_rate FROM room_availability
WHERE room_id = $1 AND date = $2 
LIMIT 1
`

type GetRoomAvailabilityByDateParams struct {
	RoomID pgtype.Int4 `json:"room_id"`
	Date   pgtype.Date `json:"date"`
}

func (q *Queries) GetRoomAvailabilityByDate(ctx context.Context, arg GetRoomAvailabilityByDateParams) (RoomAvailability, error) {
	row := q.db.QueryRow(ctx, getRoomAvailabilityByDate, arg.RoomID, arg.Date)
	var i RoomAvailability
	err := row.Scan(
		&i.RoomID,
		&i.Date,
		&i.IsAvailable,
		&i.NightRate,
	)
	return i, err
}

const listAvailableDates = `-- name: ListAvailableDates :many
SELECT date FROM room_availability
WHERE room_id = $1 AND is_available = TRUE
`

func (q *Queries) ListAvailableDates(ctx context.Context, roomID pgtype.Int4) ([]pgtype.Date, error) {
	rows, err := q.db.Query(ctx, listAvailableDates, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.Date{}
	for rows.Next() {
		var date pgtype.Date
		if err := rows.Scan(&date); err != nil {
			return nil, err
		}
		items = append(items, date)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoomAvailability = `-- name: ListRoomAvailability :many
SELECT date, is_available, night_rate FROM room_availability
WHERE room_id = $1
LIMIT 30
`

type ListRoomAvailabilityRow struct {
	Date        pgtype.Date    `json:"date"`
	IsAvailable pgtype.Bool    `json:"is_available"`
	NightRate   pgtype.Numeric `json:"night_rate"`
}

func (q *Queries) ListRoomAvailability(ctx context.Context, roomID pgtype.Int4) ([]ListRoomAvailabilityRow, error) {
	rows, err := q.db.Query(ctx, listRoomAvailability, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRoomAvailabilityRow{}
	for rows.Next() {
		var i ListRoomAvailabilityRow
		if err := rows.Scan(&i.Date, &i.IsAvailable, &i.NightRate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRoomAvailability = `-- name: UpdateRoomAvailability :exec
UPDATE room_availability
SET is_available = $3,
    night_rate = $4
WHERE room_id = $1 AND date = $2
`

type UpdateRoomAvailabilityParams struct {
	RoomID      pgtype.Int4    `json:"room_id"`
	Date        pgtype.Date    `json:"date"`
	IsAvailable pgtype.Bool    `json:"is_available"`
	NightRate   pgtype.Numeric `json:"night_rate"`
}

func (q *Queries) UpdateRoomAvailability(ctx context.Context, arg UpdateRoomAvailabilityParams) error {
	_, err := q.db.Exec(ctx, updateRoomAvailability,
		arg.RoomID,
		arg.Date,
		arg.IsAvailable,
		arg.NightRate,
	)
	return err
}
